require('isomorphic-fetch')
const invariant = require('invariant')
const clone = require('clone')

const apiKey = process.env.GOOGLE_BOOKS_API_KEY

const LRU = require("lru-cache");
const cacheOptions = { max: 50000
                   , length: function (n, key) { return n * 2 + key.length }
                   , maxAge: 1000 * 60 * 24 * 7
                   , stale: false }
const lruCache = LRU(cacheOptions);
const searchWhitelistBase = [ 'javascript', 'ruby', 'react', 'redux', 'php', 'perl', 'c++', 'node', 'rest', 'css', 'html', 'api' ]; // Add more terms that to whitelist here
let searchWhitelist;                                                    // Autogenerated on first usage

invariant(
  apiKey,
  'Missing $GOOGLE_BOOKS_API_KEY environment variable'
)

const db = {}

const defaultData = {
  currentlyReading: [ 'PGR2AwAAQBAJ', 'yDtCuFHXbAYC' ],
  wantToRead: [ 'uu1mC6zWNTwC', 'wrOQLV6xB-wC' ],
  read: [ 'pD6arNyKyi8C', '1q_xAwAAQBAJ', '32haAAAAMAAJ' ]
}

const getData = (token) => {
  let data = db[token]

  if (data == null) {
    data = db[token] = clone(defaultData)
  }

  return data
}

const getShelf = (token, bookId) => {
  const data = getData(token)
  const keys = Object.keys(data)
  return keys.find(key => data[key].includes(bookId)) || 'none'
}

const addShelf = (token) => (book) => {
  book.shelf = getShelf(token, book.id)
  return book
}

const api = 'https://www.googleapis.com/books/v1'

const createBook = (item) => Object.assign({}, item.volumeInfo, {
  id: item.id
})

const get = (token, id) => {
  console.log('books: running get for id:', id);
  const key = `${api}/volumes/${id}?key=${apiKey}`;
  var book = lruCache.get(key);
  if (book) {
    console.log('books: got LRU cache hit for book @ :', key);
    return Promise.resolve(book);
  }

  return fetch(key)
    .then(res => res.json())
    .then(createBook)
    .then((token) => {
      var book = addShelf(token);
      lruCache.set(key, book);
      return book;
    })
}

const getAll = (token) => {
  const data = getData(token)
  const bookIds = Object.keys(data).reduce((memo, shelf) => (
    memo.concat(data[shelf])
  ), [])

  return Promise.all(bookIds.map(bookId => get(token, bookId)))
}

const update = (token, bookId, shelf) =>
  new Promise(resolve => {
    const data = getData(token)

    Object.keys(data).forEach(s => {
      if (s === shelf) {
        if (!data[s].includes(bookId))
          data[s].push(bookId)
      } else {
        data[s] = data[s].filter(id => id !== bookId)
      }
    })

    resolve(data)
  })

const handleNetworkError = (response) => {
  if (!response.ok) {
    console.log('Network error:', response);
    return { code: response.code, message: response.message, reason: response.error, items:[] };
  }
  return response.json();
}

const handleAPIError = (data) => {
  if (data.error) {
    console.log('API error, response:', data);
    return { items: [] }; // simulate empty response from API
  }
  return(data);
}

const search = (token, query, maxResults = 20) => {
  // First time run, fill out the search whitelist from the base words.
  if (searchWhitelist === undefined) {
    searchWhitelist = {};
    for (let word of searchWhitelistBase) {
      for (let j = 1; j <= word.length; ++j) {
        searchWhitelist[word.substring(0,j)] = word;
      }
    }
  }
  let acceptableQuery = ''; // assume student did not choose something acceptable
  var loQuery = query.toLowerCase();
  for (let subWord in searchWhitelist) {
    console.log('Checking subword', subWord, 'against', loQuery);
    if (loQuery === subWord) {
      acceptableQuery = searchWhitelist[subWord];
      break;
    }
  }

  // if query not in whitelist return standard query results e.g. trump
  const key = `${api}/volumes?key=${apiKey}&q=${encodeURIComponent(acceptableQuery)}&maxResults=${maxResults}&fields=items(id,volumeInfo)`;
  console.log('books: running search query for : ', acceptableQuery, 'key:', key);

  var books = lruCache.get(key);
  if (books) {
    console.log('books: got LRU cache hit for books @ :', key);
    return Promise.resolve(books);
  }

  return fetch(key)
    .then(res => res.json())
    .catch(handleNetworkError)
    .then(handleAPIError)
    .then(data => data.items.map(createBook) )
    .then(books => {
      var booksMap = books.map(addShelf(token));
      lruCache.set(key, booksMap);
      return booksMap;
    })
}

module.exports = {
  get,
  getAll,
  update,
  search
}
